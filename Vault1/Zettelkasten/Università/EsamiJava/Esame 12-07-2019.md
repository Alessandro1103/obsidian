Classe Giocatore:
``` java
public class Giocatore implements Listener{
	private final String nome;
	private HashSet<Nave> navi;
	private TipoLinkHaG gioco;
	public Giocatore(String n) {
		nome = n;
		navi = new HashSet<Nave>;
	}
	public String getNome() {
		return nome;
	}
	public void inserisciTipoLinkHaG(TipoLinkHaG t) {
		if (t!=null && gioco == null)
			ManagerHaG.elimina(t);
	}
	public void eliminaTipoLinkHaG(TipoLinkHaG t) {
		if (t!=null)
			ManagerHaG.elimina(t);
	}
	public void inserisciPerManagerHaG(ManagerHaG m) {
		if (m!=null)
			gioco = m.getGioco();
	}
	public void eliminaPerManagerHaG(ManagerHaG m) {
		if (m!=null)
			gioco = null;
	}
	public TipoLinkHaG getGioco() {
		return gioco;
	}
	public void inserisciNave(Nave n) {
		if (n!=null)	
			navi.add(n);
	}
	public void eliminaNave(Nave n) {
		if (n!=null)
			navi.remove(n);
	}
	public Set<Navi> getNavi() {
		return (HashSet<Navi>) navi.clone();
	}
	public synchronized void GiocatoreFired(Evento e) {
		TaskExecutor.getIstance().perform(new GiocatoreFired(this,e))
	}
}
```

Associazioni di cui Giocatore Ã¨ responsabile:
``` java
public class ManagerHaG {
	private TipoLinkHaG link;
	private ManagerHaG(TipoLinkHaG) {
		this.link=link;
	}
	public static void inserisci(TipoLinkHaG t) {
		if (t!=null) {
			ManagerHaG m = new ManagerHaG(t);
			t.getGiocatore().inserisciPerManager(m);
			t.getGioco().insierisciPerManager(m);
		}
	}
	public static void elimina(TipoLInkHaG t) {
		if (t!=null) {
			ManagerHaG m = new ManagerHaG(t);
			t.getGiocatore().eliminaPerManager(m);
			t.getGioco().eliminaPerManager(m);
		}
	}
}

public class TipoLinkHaG {
	private final Giocatore giocatore;
	private final Gioco gioco;
	public TipoLinkHaG(Giocatore g, Gioco gi) throws EccezionePrecondizione{
		if (g==null || gi==null)
			throw new EccezionePrecondizione("Gli oggetti devono essere inizializzati");
	}
	public Giocatore getGiocatore() {
		return giocatore;
	}
	public Gioco getGioco() {
		return gioco;
	}
	public boolean equals(Object o) {
		if (o!=null && getClass().equals(o.getClass())) {
			TipoLinkHaG t = (TipoLinkHaG) o;
			return t.getGiocatore()==giocatore && t.getGioco()==gioco;
		}
		else
			return false;
	}
	public int hashCode() {
		return giocatore.hashCode() + gioco.hashCode();
	}
}
```

GiocatoreFired:
``` java
public class GiocatoreFired() implements Task{
	private boolean eseguita;
	private Coord coord;
	private Giocatore giocatore;
	private Evento evento;
	private boolean trovato;
	public GiocatoreFired(Giocatore g, Evento e) {
		giocatore = g;
		evento = e;
	}
	public synchronized void esegui() {
		if (eseguita || evento.getDestinatario()!=null && evento.getDestinatario().equals(this))
			return;
		eseguita=true;
		switch(giocatore.getStato()):
			case RIPOSO:
				if (evento.getClass()==SiGioca.class && evento.getMitt().equals(gicatore.getGioco().getArbitro())){
					Enviroment.addEvent(new False(this, null))
					giocatore.statoCorrente = Stato.INGIOCO;
				}
			case INGIOCO:
				if (evento.getClass()==Colpo.class) {
					Colpo colpo = (Colpo) evento;
					Coord coord = colpo.getPayload();
					for (Nave nave : giocatore.getNavi()) {
						if  (nave instanceof Semplice) {
							if (nave.getCoord().equals(coord))
								trovato = true;
								break;
						}
						else if (nave instanceof Speciale) {
							for(Coord c : nave.getPos()) {
								if (e.equals(coord)) {
									trovato = true;
									break;
								}
							}
						}
						if (trovato)
							break;
					}
					if (trovato)
						Enviroment.addEvent(new True(this, coord))
					else {
						Colpo c = new Colpo(this, scegliGiocatore());
						c.setCoord(scegliCoord()); 
						Enviroment.addEvent(c);
					}
				}
				else if (evento.getClass() == Fine.class && evento.getMitt().equals(gicatore.getGioco().getArbitro())) {
					gicatore.statoCorrente = Stato.RIPOSO;
				}
			default:
				throw new RunTimeException("evento non riconosciuto")
	}
	public synchronized boolean estEseguita() {
		return eseguita;
	}
}
```

Attivita Principale:
``` java
public AttivitaPrincipale implements Runnable{
	private boolean eseguita;
	private Gioco g;
	private boolean ok;
	public AttivitaPrincipale(Gioco g) {
		this.g = g;
	}
	public synchronized void run() {
		if (eseguita)
			return;
		eseguita = true;
		Verifica v = new Verifica(g);
		TaskExecutor.getIstance().perform(v);
		ok = v.getResult();
		if (!ok)
			segnaliIO.Errore();
			return;
		AttivitaGioco gioco = new AttivitaGioco(g);
		Thread t1 = new Thread(gioco);
		t1.start();
		Analisi analisi = new Analisi(g);
		Thread t2 =new Thread(analisi);
		t2.start();
		try {
			t1.join();
			t2.join();
		} catch (InterruptedException e)
			e.printStackTrace();
		CalcolaV calcolav = new CalcolaV(analisi.getResult())
		TaskExecutor.getIstance().perform(calcolav);
		segnaliIO.Report(calcolav.getResult());
		return;
	}
	public synchronized boolean estEseguita() {
		return eseguita;
	}
}
```

SottoAttivita non atomiche:
``` java
public class AttivitaGioco implements Runnable {
	private boolean eseguita;
	private Gioco g;
	public AttivitaGioco(Gioco g) {
		this.g = g;
	}
	public synchronized void run() {
		if (eseguita)
			return;
		eseguita = true;
		Avvia avvia = new Avvia(g);
		TaskExecutor.getIstance().perform(avvia);
		Fine fine = new Fine(segnaliIO.Termina().getInput());
		TaskExecutor.getIstance().perform(fine);
	}
	public synchronized boolean estEseguita() {
		return eseguita;
	}
}

public class Analisi implements Runnable {
	private boolean eseguita;
	private Gioco g;
	private HashSet<Nave> navi;
	public Analisi(Gioco g) {
		this.g = g;
	}
	public synchronized void run() {
		if (eseguita)
			return
		eseguita = true;
		Calcola calcola = new Calcola(g);
		TaskExecutor.getIstance().perform(calcola);
		navi = calcola.getResult();
	}
	public synchronized estEseguita() {
		return eseguita;
	}
	public HashSet<Nave> getResult() {
		if (!eseguita)
			throw new RuntTimeException("Evento non ancora eseguito");
		return navi;
	}
}
```

