``` java
public class Passeggeri extends Aereo{
	public Passeggeri(int pe, int po) {
		super(pe, po);
	}
	public String toString() {
		return "questo aereo è di tipo passeggeri" + super.toString();
	}
}
public class Cargo extends Aereo{
	public Cargo(int pe, int po) {
		super(pe, po);
	}
	public String toString() {
		return "questo aereo è di tipo cargo" + super.toString();
	}
}
public abstract class Aereo implements Listener {
	private final int peso;
	private final int portata;
	private Aereoporto aereoporto;
	private HashSet<TipoLinkAssegnatoP> assegnatoP;
	private Responsabile reponsabile;
	public Aereo(int peso, int portata) {
		this.peso = peso;
		this.portata = portata;
		assegnatoP = new HashSet<AssegnatoP>
	}
	public int getPeso() {
		return peso;
	}
	public int getPortata() {
		return portata;
	}
	public void inserisciAereoporto(Aereoporto a) {
		if (a!=null && aereoporto==null) 
			aereoporto=a;
	}
	public void eliminaAereoporto() {
		aereoporto=null;
	}
	public Aereoporto getAereoporto() {
		return aereoporto;
	}
		public void inserisciResponsabile(Resposabile r) {
		if (r!=null && responsabile==null) 
			responsabile=r;
	}
	public void eliminaResponsabile() {
		responsabile=null;
	}
	public Responsabile getResponsabile() {
		return restponsabile;
	}
	public void inserisciLinkAssegnatoP(TipoLinkAssegnatoP t) {
		if (t!=null && t.getAereo()==this && assegnatoP.size()<2)
			ManagerAssegnaP.inserisci(t);
	}
	public void eliminaLinkAssegnatoP(TipoLinkAssegnatoP t) {
		if (t!=null && t.getAereo()==this)
			ManagerAssegnaP.elimina(t);
	}
	public void inserisciPerManagerAssegnaP(ManagerAssegnaP m) {
		if (m!=null)
			assegnatoP.add(m.getPilota);
	}
	public void inserisciPerManagerAssegnaP(ManagerAssegnaP m) {
		if (m!=null)
			assegnatoP.remove(m.getPilota);
	}
	public Set<TipoLinkAssegnatoP> getAssegnati() {
		if (assegnatoP.size()<2)
			throw new EccezioneMolteplicita("Vincolo sulla molteplicita minima non rispettato")
		return (HashSet<TipoLinkAssegnatoP>) assegnatoP.clone();
	}
	public String toString() {
		return "Questo aereo ha peso" + peso + "e portata" + portata; 
	}
	// gestione dello stato
	public stati enum Stato {
		HANGAR, PISTA, VOLO, ATTESA, ARRIVO
	}
	Stato statoCorrente = Stato.HANGAR;
	Aereoporto destinazione;
	public Stato getStato() {
		return statoCorrente
	}
	public void AereoFired(Evento e) {
		TaskExecutor.getIstance().perform(new AereoFired(this, e))
	}
}

public class AereoFired() implements Task {
	private boolean eseguita;
	private Aereo a;
	private Evento e;
	public AereoFired(Aereo a, Evento e) {
		this.a=a;
		this.e=e;
	}
	public synchronized esegui() {
		if (eseguita || e.getDestinatario() != this && e.getDestinatario().equals(this))
			return;
		eseguita = true;
		switch(a.getStato()):
			case HANGAR:
				if (e.getClass()==Partenza.class) {
					Evento e = (Partenza) e;
					a.destinazione = e.getDestinazione();
					statoCorrente = Stato.PISTA;
				}
				break;
			case PISTA:
				if (e.getClass()==Decollo.class && e.getMittente().equals(a.getAereporto())) {
					statoCorrente = Stato.VOLO;
				}
				break;
			case VOLO:
				if (e.getClass()==Emergenza.class) {
					a.destinazione = a.aereoportoVicino();
					Enviroment.addEvent(new Richiesta(this, a.destinazione))
					statoCorrente = Stato.ATTESA;
				}
				if (e.getClass()==Atterra.class) {
					a.setAereoporto() = a.destinazione
					a.destinazione = null;
					statoCorrente = Stato.ARRIVO;
				}
				break;
			case ATTESA:
				if (e.getClass()==Rifiutato.class && e.getMittente().equals(a.destinazione)) {
					a.destinazione = a.aereoportoVicino();
					Enviroment.addEvent(new Richiesta(this, a.destinazione));
					statoCorrente = Stato.ATTESA
				}
				if (e.getClass()==Accettato.class && e.getMittente().equals(a.destinazione)) {
					a.setAereoporto() = a.destinazione;
					a.destinazione=null;
					statoCorrente = Stato.ARRIVO
				}
				break;
			default:
				throw new RunTimeException("Stato non riconosciuto")
	}
	public boolean estEseguita() {
		return eseguita;
	}
}
```

==Ho imparato== che nella classe Fired, se il mittente nel grafico è spiegato devo controllarlo tra le condizioni, le variabili ausiliari sono dentro la classe stessa. Devo sempre cercare funzioni e valori o link che variano durante i vari case

Realizzazione delle Attività:
``` java
public class AttivitaPrincipale implements Runnable{
	private boolean eseguita;
	private Aereoporto aereoporto;
	private HashSet<Aereo> aerei;
	public AttivitaPrincipale(Aereoporto a, HashSet<Aereo> ae) {
		aereoporto=a;
		aerei=ae;
	}
	public synchronized void run() {
		if (eseguita)
			return;
		eseguita = true;
		Controllo controllo = new Controllo(aereoporto, aerei);
		TaskExecutor.getIstance().perform(controllo);
		if (!a.getResult()) {
			segnaliIO.Errore();
			return;
		}
		else {
			Volo volo = new Volo(aereoporto, aerei);
			Thread t1 = new Thread(volo);
			Monitora monitora = new Monitora(aereoporto, aerei);
			Thread t2 = new Thread(volo);
			t1.start();
			t2.start();
			try {
				t1.join();
				t2.join();
			} catch (InterruptedException e){
				e.printStackTrace();
			}
			segnaliIO.Report(monitora.getResult());
		}
	}
	public synchronized estEseguita() {
		return eseguita;
	}
}

public class Monitora implements Runnable {
	private boolean eseguita;
	private HashSet<Aereo> aerei;
	private String report;
	public Monitora(HashSet<Aereo ae) {
		aerei = ae;
	}
	public synchronized void run() {
		if (eseguita)
			return;
		eseguita=true;
		while(true) {
			for (Aereo a : aerei) {
				Richiesta richiesta = new Richiesta(a);
				TaskExecutor.getIstance().perform(richiesta);
				Produzione produzione= new Produzione(richiesta.getResult());
				TaskExecutor.getIstance().perform(produzione);
				report = report + produzione.getResult();
			}
		}
	}
	public synchronized boolean estEseguita() {
		return eseguita;
	}
	public synchronized String getReport() {
		if (!eseguita)
			throw new Eccezione("report ancora non formulato");
		return report;
	}
}
```